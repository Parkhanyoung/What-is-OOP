## 비용
출시를 거듭할 때마다 코드 줄 수 추가에 따른 비용이 기하급수적으로 늘어난다.
-> 코드 분석 시간 / 코드 변경 시간이 증가하기 때문

소프트웨어의 가치는 변하는 데에 있는 것임.
근데 여기서 그냥 "keep it working like before"하게 유지하는 게 아니라,
"keep being useful in a changing world"해야 함.

결국 개발에서의 핵심은 낮은 비용으로 변화할 수 있게 만드는 것이다.
이를 위해 여러 패러다임과 아키텍처를 이용하는 것이다.

캡슐화와 다형성(추상화)가 이 비용을 낮추는 데 큰 도움이 된다.


## 객체
절차 지향은 하나의 데이터를 여러 프로시저가 공유하는 방식이다.
절차 지향은 당시에는 코딩하기 쉽지만, 시간이 지날수록 유지보수를 아주 어렵게 만든다.
점점 여러 군데를 동시에 고치고, 같은 코드를 복붙해서 사용하게 됨.

객체는 데이터와 프로시저를 묶는다.
그리고 객체 간에는 데이터를 주고 받을 수 없고, 프로시저를 호출하는 방식으로 연결된다(캡슐화).

객체에 데이터와 프로시저가 포함되긴 하지만,
사용자 입장에서는 그 세부사항을 모르고 그 기능만 알고 있으면 된다(그렇게 만들어야 한다).
그렇다면 사용자는 그 기능을 어떻게 사용할 수 있는지 알아야 하는데, 그게 바로 기능 명세이다(보통 메소드로 정의).
객체와 객체는 기능을 사용함으로써 연결된다(= 메시지를 주고 받는다 = 메소드를 호출하고 리턴받는다).

**객체의 핵심은 기능이다. 객체는 기능으로 정의한다!!**


## 캡슐화
캡슐화 == 데이터와 데이터 관련 기능을 묶는 행위
객체가 기능을 어떻게 구현했는지 상세한 정보를 외부로부터 감추는 것(정보 은닉)
-> 이런 캡슐화를 통해 외부에 영향을 안 주고 내부 로직을 변경할 수 있음

요구 사항이 바뀌면 데이터를 사용하는 방법(로직)에 변화가 생긴다.
ex. 원래는 정회원만 쓸 수 있는 기능이었는데, 준회원도 포함시키게 됨 -> 정회원 기능을 검증하는 로직이 바뀜
-> 만약 if 문으로 그때그때 분기처리한 게 아니라, 권한 여부를 반환하는 해당 객체의 메소드를 이용했다면 그 메소드만 바꾸면 됨

캡슐화 기능: 기능에 대한 의도를 이해할 수 있다, 캡슐화는 의도를 몰라서는 코딩할 수 없기 때문에 캡슐화 자체가 기능의 의도를 이해할 수 있게 만들어줌

원칙
1. Tell, Don't ask: 데이터를 달라 하지 말고 해달라고 하기. 데이터에 직접 접근하지 말고 원하는 결과만 달라고 부탁하자(판단까지 부탁하자).
2. Demeter's Law: 객체의 메서드 하나만 호출하자. 점 두개가 나오면 안 된다. 주입 받은 객체의 속성이나 메소드에 더해 추가적인 작업을 해야한다면 그 객체에 그 추가적인 작업을 처리하는 메소드를 추가하여 그 메소드 하나를 호출하는 식으로 해라.


### 다형성과 추상화
### 상속보단 조립
### 기능과 책임 분리
### 의존과 DI